------------------------------------------------------------------------

---
title: "R Notebook"
output: html_notebook
---

R Notebook creado para realizar el calculo del IPP para el año 2024

```{r}
library("readxl")
library("tidyverse")
require("tidyverse")
library("writexl")
library("tibble")
library("openxlsx")
library("DBI")
library("odbc")
library("RSQLite")
library("psych")
library("pracma")
library("bit64")
library('glue')
library('RMySQL')
library('stringi')
library('rlang')
library('ggplot2')

#source("func_test.R") #este archivo tiene el borrador de las funciones que se utilizan en el script
source("funciones.R")
```

## 1. Calculo del IPP

```{r}
#ingresa el numero del mes que se va a calcular (por el momento no toma en cuenta el año ya que se esta empezando en 2024)
mes <- 1
```

```{r}
variables <- inputdata(mes)

mes <- variables$mes
mesant <- variables$mes_ant
months <- variables$months
rows <- variables$rows

mes
mesant
months
rows
```

```{r}
#se importan las ponderaciones y se modifican los strings de los codigos para su uso dentro del script
ponderaciones <- read_excel("catalogoIPP_test.xlsx", sheet = "Sheet2") %>% 
  mutate(VARIEDAD = gsub("\\.", "", VARIEDAD)) %>% 
  rename(PRODUCTO = VARIEDAD, ponderacion = `Ponderacion 5 Digitos`) %>% 
  mutate(
    ACTIVIDAD = substr(PRODUCTO, 1, 6),
    CLASE = substr(PRODUCTO, 1, 5),
    GRUPO = substr(PRODUCTO, 1, 4),
    DIVISION = substr(PRODUCTO, 1, 3),
    SECCION = substr(PRODUCTO, 1, 1))
```

```{r}
#se importan los indices del mes anterior
file_name <- paste0("indices/ind_", mesant, ".xlsx")
indant <- read_excel(file_name, sheet = "Sheet1") %>% 
  mutate(PRODUCTO = gsub("\\.", "", PRODUCTO))
```

```{r}
#se importan los precios actuales
precios <- read_excel("precios_test.xlsx", sheet = "Sheet1") %>% 
  mutate(ACTIVIDAD = gsub("\\.", "", ACTIVIDAD),
         PRODUCTO = gsub("\\.", "", PRODUCTO),
         VARIEDAD = gsub("\\.", "", VARIEDAD))

bol <- precios %>% 
  select(PRODUCTO, VARIEDAD, all_of(mes), all_of(mesant)) %>% 
  filter(!!sym(mes) != 0) #se quitan los datos que en el mes actual son cero para imputarlos
```

### 1.1 Imputación de precios

```{r}
#se hace la imputacion de datos, y se obtiene un dataframe con todos los precios incluyendo los imputados
boleta <- imputacion()
```

### 1.2 Calculo del indice

```{r}
#se calcula el relativo de las variedades
relativo_var <- boleta %>% 
  mutate(rel_var = !!sym(mes) / !!sym(mesant)) %>% 
  mutate(rel_var = if_else(is.infinite(rel_var) | is.nan(rel_var) | is.na(rel_var), 1, rel_var)) %>%
  drop_na(PRODUCTO)
```

```{r}
#se revisan los valores de los relativos calculados
relativo_var %>% filter(rel_var > 2 | rel_var == 0)
```

```{r}
#se calcula la media geométrica de los relativos de las variedades
ind_var <- relativo_var %>% group_by(PRODUCTO) %>% 
  summarize(rel_prod = geometric.mean(rel_var))
```

```{r}
#se realiza el calculo del indice de los productos
ind_prod <- ind_var %>% left_join(indant %>% select(PRODUCTO, indice), by = join_by(PRODUCTO)) %>% 
  rename(indant = indice) %>% 
  mutate(indice = indant*rel_prod) 

#se crea un dataframe con las descripciones de los productos para añadirlas al resultado de los indices de los productos
descrip <- ponderaciones %>% filter(CCP...1 == 'PRODUCTO') %>% 
    select(PRODUCTO, DESCRIPCION, ponderacion)

ind_prod01 <- ind_prod %>% select(PRODUCTO, indice) %>% left_join(descrip, by = join_by(PRODUCTO)) %>% 
    select(PRODUCTO, DESCRIPCION, everything())
```

```{r}
#se calculan los indices de los niveles superiores utilizando la funcion "calc_indx"
ind_act <- calc_indx(ACTIVIDAD)
ind_clase <- calc_indx(CLASE)
ind_grupo <- calc_indx(GRUPO)
ind_div <- calc_indx(DIVISION)
calc_indx(SECCION) #este seria el indice general
ind <- calc_indx(SECCION)
```

### 1.3 Determinacion de precios faltantes

```{r}
#se buscan los precios faltantes en la boleta, separandolos en los que pueden ser imputados y los que no, de acuerdo al criterio previamente establecido
missing <- missing_prices()

imputables <- missing$cann_imput
no_imputables <- missing$cant_imput
```

```{r}
export_index() #Se exportan los resultados a un archivo de excel
```

### 1.4 Grafico de indice general

Se recolectan los indices generales para poder verlos en un grafico

```{r}
#se obtienen los nombres de las hojas para leer los archivos e importar los datos necesarios y generar un dataframe con los mismos
sheet_names <- paste0(months)
ipp <- readind(months, sheet_names)

resipp <- do.call(rbind, ipp) %>% rename(Mes = SECCION)
resipp$Mes <- months[1:nrow(resipp)]
resipp <- resipp %>%
  mutate(Mes = factor(Mes, levels = months))
resipp
```

```{r}
#se grafican los datos del indice general
grafica(resipp, 'Mes', 'indice')
```

### 1.5 Calculo de Incidencias

```{r}
#se realiza el calculo de incidencias a los indices de los productos utilizando la funcion "incidencias"
indgen_ant <- as.data.frame(readind(mesant, mesant)) #se importan los indices del mes anterior

incid <- incidencias(ind_prod01)
```

```{r}
#se obtienen as indicencias positivas
incid %>% filter(incid < 0)
```

```{r}
#se obtienen las incidencias negativas
incid %>% filter(incid > 0)
```

```{r}
incid %>% select(incid) %>% 
  summarize(total = sum(incid))
```

```{r}
ind$indice/indgen_ant$indice*100-100
```

### 1.6 Outliers

```{r}
#se obtienen los datos estadisticos del grupo de datos de los relativos de las variedades
summary(relativo_var$rel_var)
```

```{r}
#se realiza un histograma y una box-plot para observar el comportamiento de los datos
hist(relativo_var$rel_var,
  xlab = "relativo",
  main = "Histograma de relativo",
  breaks = sqrt(length(relativo_var$rel_var)) # set number of bins
)

boxplot(relativo_var$rel_var,
  ylab = "relativo"
)
```

```{r}
#ya que los cuartiles 1 y 3 tienen el mismo valor, no se puede realizar correctamente un analisis de quartiles, por lo que se opto por realizar un analisis con los percentiles, para este caso de tomaron limites del 1% y 99%
lim_inf <- quantile(relativo_var$rel_var, 0.025)
lim_sup <- quantile(relativo_var$rel_var, 0.975)

lim_inf
lim_sup
```

```{r}
#se buscan los outliers basado en el criterio anterior
outlier_ind <- which(relativo_var$rel_var < lim_inf | relativo_var$rel_var > lim_sup)

#se genera un dataframe con la informacion de los outliers
outliers <- relativo_var[outlier_ind, ]
outliers
```

## 2. Revision de productos faltantes

Se obtienen los articulos de los que no se obtuvo informacion cada mes

```{r}
#se importan los datos imputados y no imputados para cada mes con la función "count_imput", dicha funcion asigna el valor 1 si No hubo precio en ese mes y valor 0 si en el mes si se reporto precio
resultados <- count_imput()

#se guardan los resultados en dos datafrmaes, separando los datos faltantes en imputados y los no imputados
count_imputables <- resultados$imputados
count_noimputables <- resultados$noimputados
```

```{r}
#se revisan las variedades que no han presentado precios en tres o mas meses de las variedades que pueden imputarse
count_imputables %>% filter(total >= 3)
#test
```

```{r}
#se revisan las variedades que no han presentado precios en tres o mas meses de las variedades que no pueden imputarse
count_noimputables %>% filter(total >= 3)
#test1
```

```{r}
#se agregan las descripciones de las variedades a los resultados obtenidos anteriormente
pond_variedad <- ponderaciones %>% filter(CCP...1 == 'VARIEDAD') %>% 
  select(PRODUCTO, DESCRIPCION) %>% 
  rename('VARIEDAD' = PRODUCTO)
count_imputables1 <- count_imputables %>% left_join(pond_variedad) %>% 
  select(VARIEDAD, DESCRIPCION, everything())
count_noimputables1 <- count_noimputables %>% left_join(pond_variedad) %>% 
  select(VARIEDAD, DESCRIPCION, everything())
```

```{r}
#se guardan los resultados en un archivo de excel
wb <- createWorkbook()
 
addWorksheet(wb, "imputables")
writeData(wb, "imputables", count_imputables1)

addWorksheet(wb, "no_imputables")
writeData(wb, "no_imputables", count_noimputables1)
 
file_name <- paste0("resumen_preciosfaltantes.xlsx")
saveWorkbook(wb, file_name, overwrite = TRUE)
```

Revisamos los productos que no aparecen

```{r}
#se obtienen los productos que no aparecen en el mes de calculo, esto debido a falta de precios en las variedades que los conforman
ponderaciones %>% filter(CCP...1 == 'PRODUCTO') %>% anti_join(ind_prod01) %>% 
  select(CCP...1, PRODUCTO, DESCRIPCION, ponderacion) #%>% 
  #summarize(total = sum(ponderacion))
```

```{r}
ponderaciones %>% filter(CCP...1 == 'PRODUCTO') %>% 
  summarize(total = sum(ponderacion))
```
